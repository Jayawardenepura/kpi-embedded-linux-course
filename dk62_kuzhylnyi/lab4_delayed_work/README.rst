=============================================
Лабораторная работа №3
=============================================

Цели: 
    - За основу можно взять код из предыдущей лабораторной
    - Изучить особенности работы таймеров и workqueue
    - Реализовать два потока, запустить таймер и ворк в shared workqueue
    - При срабатывании таймера проверить текущее значение jiffies, если оно кратно 11 – остановить поток 1, иначе – таймер должен перезапустить себя через 17 jiffies
    - Внутри ворка проверить текущее значение jiffies, если оно кратно 11 – остановить поток 2, иначе – ворк должен уснуть на 17 jiffies и перезапустить себя
    - Добавить два связных списка, в которые аллоцировать и добавлять элементы со значениями jiffies, которые не привели к завершению потоков 1 и 2. Получается связь таймер - список 1 - поток 1. И ворк - список 2 - поток 2
    - При выходе из потоков распечатывать списки
    - Внутри ворка и таймера использовать правильные аллокации для новых элементов списка, правильную синхронизацию работы со списком
    - Предусмотреть, что пользователь может выгрузить модуль до отработки всех таймеров и ворков


Выполнение
-----
На основне полученных знаний о работе таймеров и workqueue в ядре линукс был разработал модуль, требования которого описаны выше. Были задейстовано два стандартных вызова kthread_run для запуска 2 потока в теле инициализации модуля. 
В каждом потоке соотвественно отрабатывает необходимый требованям ресурс.
Для проверки кратности числу 11 был использован оператор "%" - остаток от деления в операции `  if(0 == (jiffies % 11))`. Стоит заметить, что используется 32 битная переменная jiffies, вызов которой в этом и последующих участках будет атомарным.
Оба потока запускают работу двух ресурсов (ворка и таймера) через 1 jiffies `mod_timer(&base_timer, jiffies + 17)`, обработчики которые проверяют выполние указанного ранее условия и производят самоперезапуск через 17 jiffies в случае недачи и завершение работы ресурса в ином случае.

Если обратиться к полю `Интерпретация результатов` можно обратить внимание, что разница между 2мя jiffies равна 18. Можно предположить, что работа обработчика ресурса начинается не с 17-го jiffies, а именно с 18-го. Этот результат показывает очень надежное распределения ресурсов планировщика. "Неудачные" элементы со значением jiffies аллоцируются и добавляются в 2 списка, предназначенные для собственного ресурса сооствественно.

Базовые операции для работы с модулем
-----
	.. code-block:: C
		
			# make [clean]
			# insmod src/firstmod.ko Mthreads=2 Ntimes=1000xx 
			# rmmod firstmod 
			# dmesg -k | tail -20 


Интерпретация результатов для **x86_64**. 
-----

.. code-block:: C

        [ 2004.411095] Bad jiffies timer produced 
        [ 2004.411098] Node stored: [4295477815]
        [ 2004.411099] Node stored: [4295477833]
        [ 2004.411100] Node stored: [4295477851]
        [ 2004.411101] Node stored: [4295477869]
        [ 2004.411102] Node stored: [4295477887]
        [ 2004.411104] Node stored: [4295477905]
        [ 2004.411104] Bad jiffies delayed workqueue produced 
        [ 2004.411105] Node stored: [4295477796]
        [ 2004.411106] Node stored: [4295477814]
        [ 2004.411107] Node stored: [4295477832]
        [ 2004.411107] Node stored: [4295477850]



Выводы
------
В результате выполнения лабораторной работы было получено новые сведения о принципах работы нижний половин, таймере, workqueue, linked linst в ядре linux. Одной из негавных особенностей реализации данного модуля есть то, что поток, отвечающий за запуск счёта таймера в полной мере не выходит из выполнения после полного завершения работы обработчика таймера.  После того как условия кратности выполнилось, работа таймера прекращается. При этом поток выполняет неблокирующее ожидание завершения потока. Поток получает сигнал на завершение только при выгрузке модуля и, соотвественно, удаляется таймер. Причиной этого есть то, что обработчик таймер не может остановить родительский поток. Причиной этого есть то, что содержимое двух листов выводится при выгрузке, а не по завершению работы потоков.
